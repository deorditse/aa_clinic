// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscriptions_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SubscriptionsModel _$SubscriptionsModelFromJson(Map<String, dynamic> json) {
  return _SubscriptionsModel.fromJson(json);
}

/// @nodoc
mixin _$SubscriptionsModel {
  List<MarketSubscription?> get docs => throw _privateConstructorUsedError;
  int? get totalDocs => throw _privateConstructorUsedError;
  int? get limit => throw _privateConstructorUsedError;
  int get page => throw _privateConstructorUsedError;
  int get totalPages => throw _privateConstructorUsedError;
  bool get hasPrevPage => throw _privateConstructorUsedError;
  bool get hasNextPage => throw _privateConstructorUsedError;
  int? get prevPage => throw _privateConstructorUsedError;
  int? get nextPage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubscriptionsModelCopyWith<SubscriptionsModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionsModelCopyWith<$Res> {
  factory $SubscriptionsModelCopyWith(
          SubscriptionsModel value, $Res Function(SubscriptionsModel) then) =
      _$SubscriptionsModelCopyWithImpl<$Res, SubscriptionsModel>;
  @useResult
  $Res call(
      {List<MarketSubscription?> docs,
      int? totalDocs,
      int? limit,
      int page,
      int totalPages,
      bool hasPrevPage,
      bool hasNextPage,
      int? prevPage,
      int? nextPage});
}

/// @nodoc
class _$SubscriptionsModelCopyWithImpl<$Res, $Val extends SubscriptionsModel>
    implements $SubscriptionsModelCopyWith<$Res> {
  _$SubscriptionsModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? docs = null,
    Object? totalDocs = freezed,
    Object? limit = freezed,
    Object? page = null,
    Object? totalPages = null,
    Object? hasPrevPage = null,
    Object? hasNextPage = null,
    Object? prevPage = freezed,
    Object? nextPage = freezed,
  }) {
    return _then(_value.copyWith(
      docs: null == docs
          ? _value.docs
          : docs // ignore: cast_nullable_to_non_nullable
              as List<MarketSubscription?>,
      totalDocs: freezed == totalDocs
          ? _value.totalDocs
          : totalDocs // ignore: cast_nullable_to_non_nullable
              as int?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      totalPages: null == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int,
      hasPrevPage: null == hasPrevPage
          ? _value.hasPrevPage
          : hasPrevPage // ignore: cast_nullable_to_non_nullable
              as bool,
      hasNextPage: null == hasNextPage
          ? _value.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool,
      prevPage: freezed == prevPage
          ? _value.prevPage
          : prevPage // ignore: cast_nullable_to_non_nullable
              as int?,
      nextPage: freezed == nextPage
          ? _value.nextPage
          : nextPage // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SubscriptionsModelCopyWith<$Res>
    implements $SubscriptionsModelCopyWith<$Res> {
  factory _$$_SubscriptionsModelCopyWith(_$_SubscriptionsModel value,
          $Res Function(_$_SubscriptionsModel) then) =
      __$$_SubscriptionsModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<MarketSubscription?> docs,
      int? totalDocs,
      int? limit,
      int page,
      int totalPages,
      bool hasPrevPage,
      bool hasNextPage,
      int? prevPage,
      int? nextPage});
}

/// @nodoc
class __$$_SubscriptionsModelCopyWithImpl<$Res>
    extends _$SubscriptionsModelCopyWithImpl<$Res, _$_SubscriptionsModel>
    implements _$$_SubscriptionsModelCopyWith<$Res> {
  __$$_SubscriptionsModelCopyWithImpl(
      _$_SubscriptionsModel _value, $Res Function(_$_SubscriptionsModel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? docs = null,
    Object? totalDocs = freezed,
    Object? limit = freezed,
    Object? page = null,
    Object? totalPages = null,
    Object? hasPrevPage = null,
    Object? hasNextPage = null,
    Object? prevPage = freezed,
    Object? nextPage = freezed,
  }) {
    return _then(_$_SubscriptionsModel(
      docs: null == docs
          ? _value._docs
          : docs // ignore: cast_nullable_to_non_nullable
              as List<MarketSubscription?>,
      totalDocs: freezed == totalDocs
          ? _value.totalDocs
          : totalDocs // ignore: cast_nullable_to_non_nullable
              as int?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      totalPages: null == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int,
      hasPrevPage: null == hasPrevPage
          ? _value.hasPrevPage
          : hasPrevPage // ignore: cast_nullable_to_non_nullable
              as bool,
      hasNextPage: null == hasNextPage
          ? _value.hasNextPage
          : hasNextPage // ignore: cast_nullable_to_non_nullable
              as bool,
      prevPage: freezed == prevPage
          ? _value.prevPage
          : prevPage // ignore: cast_nullable_to_non_nullable
              as int?,
      nextPage: freezed == nextPage
          ? _value.nextPage
          : nextPage // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubscriptionsModel implements _SubscriptionsModel {
  const _$_SubscriptionsModel(
      {final List<MarketSubscription?> docs = const [],
      this.totalDocs,
      this.limit,
      required this.page,
      required this.totalPages,
      this.hasPrevPage = false,
      this.hasNextPage = false,
      this.prevPage,
      this.nextPage})
      : _docs = docs;

  factory _$_SubscriptionsModel.fromJson(Map<String, dynamic> json) =>
      _$$_SubscriptionsModelFromJson(json);

  final List<MarketSubscription?> _docs;
  @override
  @JsonKey()
  List<MarketSubscription?> get docs {
    if (_docs is EqualUnmodifiableListView) return _docs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_docs);
  }

  @override
  final int? totalDocs;
  @override
  final int? limit;
  @override
  final int page;
  @override
  final int totalPages;
  @override
  @JsonKey()
  final bool hasPrevPage;
  @override
  @JsonKey()
  final bool hasNextPage;
  @override
  final int? prevPage;
  @override
  final int? nextPage;

  @override
  String toString() {
    return 'SubscriptionsModel(docs: $docs, totalDocs: $totalDocs, limit: $limit, page: $page, totalPages: $totalPages, hasPrevPage: $hasPrevPage, hasNextPage: $hasNextPage, prevPage: $prevPage, nextPage: $nextPage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubscriptionsModel &&
            const DeepCollectionEquality().equals(other._docs, _docs) &&
            (identical(other.totalDocs, totalDocs) ||
                other.totalDocs == totalDocs) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.hasPrevPage, hasPrevPage) ||
                other.hasPrevPage == hasPrevPage) &&
            (identical(other.hasNextPage, hasNextPage) ||
                other.hasNextPage == hasNextPage) &&
            (identical(other.prevPage, prevPage) ||
                other.prevPage == prevPage) &&
            (identical(other.nextPage, nextPage) ||
                other.nextPage == nextPage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_docs),
      totalDocs,
      limit,
      page,
      totalPages,
      hasPrevPage,
      hasNextPage,
      prevPage,
      nextPage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubscriptionsModelCopyWith<_$_SubscriptionsModel> get copyWith =>
      __$$_SubscriptionsModelCopyWithImpl<_$_SubscriptionsModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubscriptionsModelToJson(
      this,
    );
  }
}

abstract class _SubscriptionsModel implements SubscriptionsModel {
  const factory _SubscriptionsModel(
      {final List<MarketSubscription?> docs,
      final int? totalDocs,
      final int? limit,
      required final int page,
      required final int totalPages,
      final bool hasPrevPage,
      final bool hasNextPage,
      final int? prevPage,
      final int? nextPage}) = _$_SubscriptionsModel;

  factory _SubscriptionsModel.fromJson(Map<String, dynamic> json) =
      _$_SubscriptionsModel.fromJson;

  @override
  List<MarketSubscription?> get docs;
  @override
  int? get totalDocs;
  @override
  int? get limit;
  @override
  int get page;
  @override
  int get totalPages;
  @override
  bool get hasPrevPage;
  @override
  bool get hasNextPage;
  @override
  int? get prevPage;
  @override
  int? get nextPage;
  @override
  @JsonKey(ignore: true)
  _$$_SubscriptionsModelCopyWith<_$_SubscriptionsModel> get copyWith =>
      throw _privateConstructorUsedError;
}

MarketSubscription _$MarketSubscriptionFromJson(Map<String, dynamic> json) {
  return _MarketSubscription.fromJson(json);
}

/// @nodoc
mixin _$MarketSubscription {
  String get id => throw _privateConstructorUsedError;
  String? get creatorId => throw _privateConstructorUsedError;
  int? get pricePerMonth => throw _privateConstructorUsedError;
  String? get currency => throw _privateConstructorUsedError;
  String? get currencyCode => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get mark => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;
  String? get createdAt => throw _privateConstructorUsedError;
  String? get updatedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MarketSubscriptionCopyWith<MarketSubscription> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MarketSubscriptionCopyWith<$Res> {
  factory $MarketSubscriptionCopyWith(
          MarketSubscription value, $Res Function(MarketSubscription) then) =
      _$MarketSubscriptionCopyWithImpl<$Res, MarketSubscription>;
  @useResult
  $Res call(
      {String id,
      String? creatorId,
      int? pricePerMonth,
      String? currency,
      String? currencyCode,
      String? title,
      String? description,
      String? mark,
      String? image,
      String? createdAt,
      String? updatedAt});
}

/// @nodoc
class _$MarketSubscriptionCopyWithImpl<$Res, $Val extends MarketSubscription>
    implements $MarketSubscriptionCopyWith<$Res> {
  _$MarketSubscriptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? creatorId = freezed,
    Object? pricePerMonth = freezed,
    Object? currency = freezed,
    Object? currencyCode = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? mark = freezed,
    Object? image = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      creatorId: freezed == creatorId
          ? _value.creatorId
          : creatorId // ignore: cast_nullable_to_non_nullable
              as String?,
      pricePerMonth: freezed == pricePerMonth
          ? _value.pricePerMonth
          : pricePerMonth // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: freezed == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String?,
      currencyCode: freezed == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      mark: freezed == mark
          ? _value.mark
          : mark // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MarketSubscriptionCopyWith<$Res>
    implements $MarketSubscriptionCopyWith<$Res> {
  factory _$$_MarketSubscriptionCopyWith(_$_MarketSubscription value,
          $Res Function(_$_MarketSubscription) then) =
      __$$_MarketSubscriptionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String? creatorId,
      int? pricePerMonth,
      String? currency,
      String? currencyCode,
      String? title,
      String? description,
      String? mark,
      String? image,
      String? createdAt,
      String? updatedAt});
}

/// @nodoc
class __$$_MarketSubscriptionCopyWithImpl<$Res>
    extends _$MarketSubscriptionCopyWithImpl<$Res, _$_MarketSubscription>
    implements _$$_MarketSubscriptionCopyWith<$Res> {
  __$$_MarketSubscriptionCopyWithImpl(
      _$_MarketSubscription _value, $Res Function(_$_MarketSubscription) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? creatorId = freezed,
    Object? pricePerMonth = freezed,
    Object? currency = freezed,
    Object? currencyCode = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? mark = freezed,
    Object? image = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_$_MarketSubscription(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      creatorId: freezed == creatorId
          ? _value.creatorId
          : creatorId // ignore: cast_nullable_to_non_nullable
              as String?,
      pricePerMonth: freezed == pricePerMonth
          ? _value.pricePerMonth
          : pricePerMonth // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: freezed == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String?,
      currencyCode: freezed == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      mark: freezed == mark
          ? _value.mark
          : mark // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as String?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MarketSubscription implements _MarketSubscription {
  const _$_MarketSubscription(
      {required this.id,
      this.creatorId,
      this.pricePerMonth,
      this.currency,
      this.currencyCode,
      this.title,
      this.description,
      this.mark,
      this.image,
      this.createdAt,
      this.updatedAt});

  factory _$_MarketSubscription.fromJson(Map<String, dynamic> json) =>
      _$$_MarketSubscriptionFromJson(json);

  @override
  final String id;
  @override
  final String? creatorId;
  @override
  final int? pricePerMonth;
  @override
  final String? currency;
  @override
  final String? currencyCode;
  @override
  final String? title;
  @override
  final String? description;
  @override
  final String? mark;
  @override
  final String? image;
  @override
  final String? createdAt;
  @override
  final String? updatedAt;

  @override
  String toString() {
    return 'MarketSubscription(id: $id, creatorId: $creatorId, pricePerMonth: $pricePerMonth, currency: $currency, currencyCode: $currencyCode, title: $title, description: $description, mark: $mark, image: $image, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MarketSubscription &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.creatorId, creatorId) ||
                other.creatorId == creatorId) &&
            (identical(other.pricePerMonth, pricePerMonth) ||
                other.pricePerMonth == pricePerMonth) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.mark, mark) || other.mark == mark) &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      creatorId,
      pricePerMonth,
      currency,
      currencyCode,
      title,
      description,
      mark,
      image,
      createdAt,
      updatedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MarketSubscriptionCopyWith<_$_MarketSubscription> get copyWith =>
      __$$_MarketSubscriptionCopyWithImpl<_$_MarketSubscription>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MarketSubscriptionToJson(
      this,
    );
  }
}

abstract class _MarketSubscription implements MarketSubscription {
  const factory _MarketSubscription(
      {required final String id,
      final String? creatorId,
      final int? pricePerMonth,
      final String? currency,
      final String? currencyCode,
      final String? title,
      final String? description,
      final String? mark,
      final String? image,
      final String? createdAt,
      final String? updatedAt}) = _$_MarketSubscription;

  factory _MarketSubscription.fromJson(Map<String, dynamic> json) =
      _$_MarketSubscription.fromJson;

  @override
  String get id;
  @override
  String? get creatorId;
  @override
  int? get pricePerMonth;
  @override
  String? get currency;
  @override
  String? get currencyCode;
  @override
  String? get title;
  @override
  String? get description;
  @override
  String? get mark;
  @override
  String? get image;
  @override
  String? get createdAt;
  @override
  String? get updatedAt;
  @override
  @JsonKey(ignore: true)
  _$$_MarketSubscriptionCopyWith<_$_MarketSubscription> get copyWith =>
      throw _privateConstructorUsedError;
}
